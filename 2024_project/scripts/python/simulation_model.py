import numpy as np

class EconomicModel:
    def __init__(self, num_agents, supply_of_permits, permit_price):
        """
        Initialize the economic model.
        :param num_agents: Number of agents participating in the market.
        :param supply_of_permits: Total number of permits available.
        :param permit_price: Initial price of permits.
        """
        self.num_agents = num_agents
        self.supply_of_permits = supply_of_permits
        self.permit_price = permit_price
        self.demands = np.random.rand(num_agents)  # Random demands for simulation purposes
        self.allocations = np.zeros(num_agents)   # Allocations of permits to agents
        self.utilities = np.zeros(num_agents)     # Utilities of agents based on allocations

    def setup_market(self):
        """
        Setup initial market conditions, potentially including initial allocation.
        """
        # Initial allocation could be equal, random, or based on some policy
        initial_allocation = self.supply_of_permits / self.num_agents
        self.allocations.fill(initial_allocation)

    def run_simulation(self):
        """
        Simulate the trading or allocation process.
        """
        # Placeholder for allocation mechanism; for now, we simulate some trading
        for i in range(self.num_agents):
            trade_amount = np.random.rand() * 10  # Simulate trading up to 10 units
            self.allocations[i] += trade_amount
            self.permit_price += np.random.rand() - 0.5  # Random walk for the price

    def collect_results(self):
        """
        Calculate and return the utilities for each agent based on final allocations.
        """
        # Utility calculation based on some function of allocation and demand
        for i in range(self.num_agents):
            utility = self.demands[i] * np.log(self.allocations[i])  # Example: logarithmic utility function
            self.utilities[i] = utility
        return self.utilities

    def calculate_total_welfare(self):
        """
        Calculate the total welfare generated by the current allocations.
        """
        return np.sum(self.utilities)
    
